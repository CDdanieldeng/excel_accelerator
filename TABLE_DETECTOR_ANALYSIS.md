# TableDetector 表头检测逻辑分析

## 当前实现逻辑

### 1. 表头检测流程

```
detect_sheet()
  └─> _find_header_row()  # 在前 N 行中找最可能的表头行
       └─> _calculate_header_score()  # 对每一行计算"表头得分"
  └─> _extract_columns()  # 从选中的表头行提取列名
```

### 2. 表头得分计算 (`_calculate_header_score`)

当前算法对每一行计算一个得分，得分越高越可能是表头：

**评分规则：**
1. **文本比例** (权重 0.7)
   - 文本单元格越多，得分越高
   - `text_ratio = text_count / total_cells`

2. **数字比例** (权重 -0.3，惩罚项)
   - 数字单元格越多，得分越低
   - `numeric_ratio = numeric_count / total_cells`

3. **非空单元格数量** (加分项)
   - 如果非空单元格数量 >= 3，额外加 0.2 分
   - 表头通常有多个列

**计算公式：**
```python
score = text_ratio * 0.7 - numeric_ratio * 0.3
if non_empty_count >= 3:
    score += 0.2
```

### 3. 表头行选择 (`_find_header_row`)

- 在前 `max_header_search_rows` 行（默认 20 行）中搜索
- 对每一行计算得分
- **选择得分最高的那一行**作为表头行
- 只返回**单一行索引**

### 4. 列名提取 (`_extract_columns`)

- 从选中的表头行中提取所有非空单元格
- 去除尾部空列
- 返回列名列表

## 当前实现的局限性

### ❌ 问题 1: 只支持单行表头

**场景示例：**
```
行 0: [公司信息]     [销售数据]     [财务数据]
行 1: [名称] [地址]  [数量] [金额]  [收入] [支出]
行 2: 数据开始...
```

**当前行为：**
- 可能会选择行 1（因为文本更多、更具体）
- 或者选择行 0（如果行 0 的得分更高）
- **无法同时识别两行都是表头**

**期望行为：**
- 识别行 0 和行 1 都是表头
- 合并多行表头生成完整列名（如："公司信息/名称"、"销售数据/数量"）

### ❌ 问题 2: 无法处理合并单元格

**场景示例：**
```
行 0: [合并单元格: 公司信息]  [合并单元格: 销售数据]
行 1: [名称] [地址]            [数量] [金额]
```

**当前行为：**
- 合并单元格在读取时可能显示为：`["公司信息", None, "销售数据", None]`
- 算法无法识别这些 `None` 是合并单元格的一部分
- 可能会错误地选择行 1 作为表头

### ❌ 问题 3: 没有考虑表头连续性

**场景示例：**
```
行 0: [标题1] [标题2] [标题3]  # 表头行 1
行 1: [子1]   [子2]   [子3]    # 表头行 2
行 2: [空]    [空]    [空]     # 空行
行 3: 数据开始...
```

**当前行为：**
- 可能会选择行 0 或行 1
- 无法识别行 0 和行 1 是连续的表头行
- 空行会打断表头检测

### ❌ 问题 4: 没有考虑数据模式验证

**当前行为：**
- 只基于单行的特征（文本/数字比例）判断
- 没有验证"表头行之后的数据是否符合表头结构"

**期望行为：**
- 如果某行是表头，那么后续行应该是数据
- 数据行的特征应该与表头行不同（更多数字、更少文本）

### ❌ 问题 5: 无法处理表头在中间的情况

**场景示例：**
```
行 0-4:  一些说明文字或空行
行 5:    [列1] [列2] [列3]  # 真正的表头
行 6:    数据开始...
```

**当前行为：**
- 如果前 20 行中有其他文本行，可能会误选
- 但如果表头在第 5 行，且前 4 行都是空行或说明，应该能正确识别

## 多行表头的常见模式

### 模式 1: 两级表头（最常见）

```
行 0: [一级标题1]        [一级标题2]
行 1: [二级1] [二级2]     [二级3] [二级4]
行 2: 数据...
```

### 模式 2: 三级表头

```
行 0: [一级标题]
行 1: [二级1]     [二级2]
行 2: [三级1] [三级2] [三级3] [三级4]
行 3: 数据...
```

### 模式 3: 混合表头（部分合并）

```
行 0: [合并: 公司信息]  [销售]  [财务]
行 1: [名称] [地址]     [数量]  [收入] [支出]
行 2: 数据...
```

### 模式 4: 带空行的表头

```
行 0: [标题1] [标题2]
行 1: [空]    [空]
行 2: [子1]   [子2]
行 3: 数据...
```

## 改进建议

### 方案 1: 检测表头区域（而非单行）

1. **识别表头区域**：
   - 检测连续的多行，这些行都符合表头特征
   - 考虑空行作为分隔符

2. **合并多行表头**：
   - 将多行表头合并成完整的列名
   - 处理合并单元格的情况

### 方案 2: 数据模式验证

1. **验证表头候选**：
   - 如果某行是表头，后续行应该是数据
   - 数据行应该有更多数字、更少文本

2. **双向验证**：
   - 从表头向下验证数据
   - 从数据向上验证表头

### 方案 3: 更智能的评分系统

1. **考虑上下文**：
   - 如果上一行也是表头候选，当前行更可能是表头
   - 如果下一行是数据，当前行更可能是表头

2. **多行联合评分**：
   - 不仅评估单行，还评估多行组合
   - 选择得分最高的表头区域

### 方案 4: 支持配置

1. **允许用户指定表头行数**：
   - 如果知道是 2 行表头，可以指定 `header_rows=2`

2. **学习模式**：
   - 从用户反馈中学习，改进检测算法

## 当前实现的优点

✅ **简单高效**：算法简单，运行快速  
✅ **单行表头效果好**：对于标准的单行表头，检测准确率较高  
✅ **易于理解**：逻辑清晰，容易调试  
✅ **可扩展**：代码结构良好，易于添加新功能

## 总结

当前的 `TableDetector` 实现：
- ✅ **适合**：标准的单行表头 Excel/CSV 文件
- ❌ **不适合**：多行表头、合并单元格、复杂表头结构

如果需要支持多行表头，需要：
1. 重新设计表头检测算法（检测区域而非单行）
2. 实现多行表头合并逻辑
3. 添加数据模式验证
4. 考虑合并单元格的处理

