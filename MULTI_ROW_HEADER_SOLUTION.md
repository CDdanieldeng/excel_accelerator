# 多行表头检测解决方案

## 概述

新的 `TableDetector` 实现支持多行表头检测，解决了原版本只能检测单行表头的限制。

## 核心改进

### 1. 表头区域检测（而非单行）

**原实现：**
- 只选择得分最高的一行作为表头

**新实现：**
- 检测连续的多行表头区域（1-5 行）
- 考虑表头的连续性和上下文
- 自动选择最佳的表头区域大小

### 2. 数据模式验证

**新增功能：**
- 验证表头候选：如果某行是表头，后续行应该是数据
- 数据行特征：更多数字、更少文本
- 双向验证：表头得分应该高于数据得分

**验证逻辑：**
```python
def _validate_header_candidate(rows, header_start, header_end):
    # 检查表头行之后的几行数据
    # 数据行应该有更高的数据得分
    # 表头行应该有更高的表头得分
    # 返回验证分数
```

### 3. 多行表头合并

**支持的模式：**

#### 模式 1: 两级表头
```
行 0: [一级标题1]        [一级标题2]
行 1: [二级1] [二级2]     [二级3] [二级4]
结果: [一级标题1/二级1, 一级标题1/二级2, 一级标题2/二级3, 一级标题2/二级4]
```

#### 模式 2: 三级表头
```
行 0: [一级标题]
行 1: [二级1]     [二级2]
行 2: [三级1] [三级2] [三级3] [三级4]
结果: [一级标题/二级1/三级1, 一级标题/二级1/三级2, ...]
```

#### 模式 3: 合并单元格处理
```
行 0: [合并: 公司信息]  [销售]  [财务]
行 1: [名称] [地址]     [数量]  [收入] [支出]
结果: [公司信息/名称, 公司信息/地址, 销售/数量, 财务/收入, 财务/支出]
```

### 4. 智能评分系统

**改进的评分算法：**

1. **单行评分**（保留原有逻辑）
   - 文本比例高 → 加分
   - 数字比例高 → 减分
   - 非空单元格多 → 加分

2. **区域评分**（新增）
   - 计算多行表头区域的平均得分
   - 结合数据验证分数
   - 选择综合得分最高的区域

3. **上下文考虑**（新增）
   - 如果上一行也是表头候选，当前行更可能是表头
   - 如果下一行是数据，当前行更可能是表头
   - 空行会打断表头区域

## 算法流程

```
1. 计算前 N 行中每一行的表头得分
   └─> _calculate_header_score()

2. 尝试不同大小的表头区域（1-5 行）
   └─> 计算区域平均得分
   └─> 验证后续行是否为数据
   └─> 计算综合得分

3. 选择最佳表头区域
   └─> 如果多行表头得分显著高于单行，选择多行
   └─> 否则选择单行（向后兼容）

4. 合并多行表头
   └─> _merge_multi_row_header()
   └─> 处理合并单元格
   └─> 生成完整列名（用 "/" 分隔）

5. 返回结果
   └─> header_row_indices: 所有表头行索引
   └─> detected_columns: 合并后的列名
```

## 使用示例

### 基本用法

```python
from backend.services.table_detector import TableDetector
from backend.services.file_loader import load_file_sample

# 加载文件
samples = load_file_sample("test.xlsx", "xlsx", max_scan_rows=200)

# 检测表头
detector = TableDetector()
for sample in samples:
    result = detector.detect_sheet(sample.name, sample.rows)
    
    # 单行表头
    if len(result.header_row_indices) == 1:
        print(f"单行表头: 第 {result.header_row_index + 1} 行")
    # 多行表头
    else:
        print(f"多行表头: 第 {result.header_row_indices[0] + 1} 到 {result.header_row_indices[-1] + 1} 行")
    
    # 合并后的列名
    for col in result.detected_columns:
        print(f"  - {col}")
```

### 测试脚本

```bash
# 测试多行表头检测
python test_detector.py your_file.xlsx
```

## API 变化

### 数据模型更新

**`SheetGuessResult` 新增字段：**

```python
class SheetGuessResult(BaseModel):
    header_row_index: int  # 保留（向后兼容）
    header_row_indices: List[int]  # 新增：所有表头行索引
    detected_columns: List[str]  # 更新：多行表头会合并（用 "/" 分隔）
```

### 向后兼容性

- ✅ `header_row_index` 字段保留，始终等于 `header_row_indices[0]`
- ✅ 单行表头的行为与之前完全一致
- ✅ API 响应格式兼容（只是新增了字段）

## 性能考虑

### 时间复杂度

- **单行检测**: O(N) - N 是搜索行数
- **多行检测**: O(N × M) - M 是尝试的区域大小（最多 5）
- **总体**: 仍然很快，因为 N 通常只有 20-200 行

### 优化策略

1. **限制搜索范围**: 默认只搜索前 20 行
2. **限制区域大小**: 最多尝试 5 行表头
3. **早期退出**: 如果找到高质量的单行表头，可能跳过多行检测

## 已知限制

### 1. 合并单元格检测

- **问题**: 合并单元格在读取时可能显示为 `None`
- **当前处理**: 通过检查左侧邻居单元格来推断
- **改进方向**: 需要从文件格式层面获取合并信息

### 2. 复杂表头结构

- **问题**: 如果表头中有空行分隔，可能无法正确识别
- **当前处理**: 空行会打断表头区域
- **改进方向**: 可以配置允许的空行数量

### 3. 表头在中间

- **问题**: 如果表头在第 50 行，但只搜索前 20 行，会错过
- **当前处理**: 可以通过 `max_header_search_rows` 参数调整
- **改进方向**: 可以添加"表头可能在中间"的检测模式

## 测试建议

### 测试用例

1. **单行表头**（应该与之前行为一致）
   ```
   行 0: [列1] [列2] [列3]
   行 1: 数据...
   ```

2. **两级表头**
   ```
   行 0: [一级1]     [一级2]
   行 1: [二级1] [二级2] [二级3] [二级4]
   行 2: 数据...
   ```

3. **三级表头**
   ```
   行 0: [一级]
   行 1: [二级1]     [二级2]
   行 2: [三级1] [三级2] [三级3] [三级4]
   行 3: 数据...
   ```

4. **带空行的表头**
   ```
   行 0: [标题1] [标题2]
   行 1: [空]    [空]
   行 2: [子1]   [子2]
   行 3: 数据...
   ```

5. **表头在中间**
   ```
   行 0-4: 说明文字
   行 5:   [列1] [列2] [列3]
   行 6:   数据...
   ```

## 调试技巧

### 启用详细日志

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

### 查看评分详情

日志会显示：
- 每一行的表头得分
- 每个表头区域的综合得分
- 数据验证分数

### 使用测试脚本

```bash
# 查看详细的检测过程
python test_detector.py your_file.xlsx 500 100
```

## 未来改进方向

1. **合并单元格支持**: 从文件格式获取合并信息
2. **自适应搜索**: 根据文件特征调整搜索范围
3. **机器学习**: 使用 ML 模型提高检测准确率
4. **用户反馈**: 允许用户纠正检测结果，学习改进

## 总结

新的多行表头检测实现：

✅ **支持多行表头**: 自动检测 1-5 行表头  
✅ **数据验证**: 通过验证后续数据行提高准确率  
✅ **智能合并**: 自动合并多行表头生成完整列名  
✅ **向后兼容**: 单行表头行为完全一致  
✅ **性能良好**: 检测速度仍然很快  

现在可以处理更复杂的 Excel 表头结构了！

